package 栈;

public class _0_思路 {
	/*
	 *  1. 删除最外层的括号: 括号匹配有最近匹配原则, 左括号push进栈, 右括号总是和栈顶的左括号相匹配. 类似这种中间对称的比较适合使用栈
	 *  
	 *  2. 删除字符串中的所有相邻重复项: 遍历字符串的每一个字符, 并push进栈, 当新遍历到的字符 == 栈底的元素时候, 就pop出栈底的元素, 这样所有相邻的元素都会被pop出来;
	 *  
	 *  3. 用队列实现栈: 用两个队列, 先将新元素push进空队列A, 然后将保存之前元素的队列B里的每个元素pop出来并push进A队列中.
	 *  
	 *  4. 用栈实现队列: 用两个栈, 先将用来保存元素的栈A中的每个元素pop出来并push到空栈B中, 然后将新元素push进A栈中, 再将B中的每个元素pop出来并push到A中;
	 *  
	 *  5. 比较含退格的字符串: 退格字符删除的总是最后输入的元素, 符合使用栈的思维.  类似这种优先处理最近输入的元素的处理, 适合使用栈.
	 *  
	 *  6. 最小栈: 对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。 因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。
	 *  
	 *  
	 * */
}
